The Internet of Things (IoT) has become an integral part of our everyday lives, automating processes and making devices smarter. One of the key protocols that power this interconnected network is MQTT (Message Queuing Telemetry Transport). MQTT facilitates communication between various IoT devices, allowing them to send and receive messages, subscribe to topics, and trigger actions based on specific conditions. While MQTT makes these devices incredibly efficient and responsive, it also opens the door to potential security vulnerabilities. In this write-up, I’ll take you through my hands-on experience of learning how MQTT works, monitoring network traffic using Wireshark, and solving an IoT-related challenge to bring a system back online.

### The Basics of MQTT and How It Works

To understand the challenge, I first needed to grasp the fundamentals of the MQTT protocol. MQTT follows a **publish/subscribe model**, where devices (called *clients*) either publish messages to specific topics or subscribe to those topics to receive messages. This protocol is highly efficient, making it ideal for IoT systems where multiple devices need to communicate with each other while minimizing bandwidth consumption.

#### Key Concepts:
1. **MQTT Clients**: These are the devices that either send or receive messages. For instance, a temperature sensor might be a publisher, sending temperature readings. An HVAC controller, on the other hand, might be a subscriber to that temperature data, reacting to the readings by adjusting the heating system.
   
2. **MQTT Broker**: This is the central hub where all the clients connect. The broker receives messages from publishers and forwards them to subscribers based on their topics of interest.
   
3. **MQTT Topics**: These are the categories or channels under which messages are organized. For example, a topic might be "home/temperature" or "home/heater". Devices subscribe to topics to receive the relevant data. 

In the beginning, the concept of MQTT was somewhat abstract, but diving into practical examples made it much clearer. MQTT is essentially a messaging protocol that allows devices to talk to each other efficiently and with minimal data overhead.

### Hands-On with MQTT in the Virtual Environment

I was tasked with restoring the lights in a factory system that had been sabotaged. To better understand the MQTT protocol in practice, I started with a simulation environment where the components of the IoT system were already set up. In the VM, several scripts were designed to simulate the MQTT communication between devices, and my goal was to use **Wireshark** to capture MQTT traffic and figure out how the sabotage occurred.

I started by opening the terminal and running the `walkthrough.sh` script. This script set up the MQTT broker, the HVAC controller, and a simulated user interface. Upon running the script, I could see three windows pop up—one for the MQTT broker, another for the HVAC controller (simulating a temperature control system), and the third for the application UI (where the user interacts with the system). This gave me a real-world feel of how the MQTT protocol operates in an IoT environment.

I used **Wireshark** to monitor the network traffic generated by these devices. By filtering for MQTT traffic (`mqtt` filter in Wireshark), I could see all the messages being sent between the MQTT broker and the clients. I observed connection establishments, subscription requests, and published messages with various topics, such as "home/temperature" and "home/heater". This was my first real glimpse of how IoT devices use MQTT to communicate with each other.

The sequence of events was simple yet insightful:
1. The HVAC controller subscribed to the "home/temperature" topic.
2. The temperature sensor published temperature readings to this topic.
3. The HVAC controller reacted by publishing a message under the "home/heater" topic, turning the heater on.

At this point, I had a basic understanding of how MQTT works and how devices communicate in an IoT system.

### The Challenge: Restoring the Lights

After getting comfortable with MQTT, I moved on to the challenge, which involved a sabotaged lighting system. The goal was to find the MQTT message that would turn the lights back on. The first step was to run the `challenge.sh` script, which simulated the broken lighting system.

When I opened the lights controller interface, I found that the system was non-responsive. There was no way to turn the lights back on, and the interface didn’t provide any obvious solutions. However, I knew that the communication to control the lights was most likely happening through MQTT, and all I needed to do was figure out the correct MQTT topic and message that would trigger the lights to turn on.

At this point, I opened **Wireshark** again, but this time to analyze the `challenge.pcapng` file provided in the challenge folder. This capture file contained the MQTT communication between the devices related to controlling the lights. By carefully inspecting the captured packets, I searched for patterns and clues that would reveal the correct topic and message.

After a detailed analysis, I found the right topic and message to turn the lights back on. The process was akin to reverse-engineering the communication between the devices. Once I had identified the correct topic and message, I used the `mosquitto_pub` command to publish the message to the MQTT broker.

The command I used was:
```bash
mosquitto_pub -h localhost -t "lights/control" -m "on"
```
Here, `-h localhost` refers to the local MQTT broker, `-t "lights/control"` is the topic related to controlling the lights, and `-m "on"` is the message that instructs the system to turn the lights on.

As soon as I published the message, the lights turned on, and the flag appeared on the lights controller interface. Success! I had restored the lights and solved the challenge.

### Reflections and Key Takeaways

This exercise was an excellent opportunity to dive deep into the MQTT protocol and see how IoT devices communicate with each other. The key takeaway for me was how important it is to monitor network traffic and understand the underlying protocols that power IoT systems. In this case, MQTT was the key to everything, and once I understood how it worked, solving the challenge became a matter of reverse-engineering the communication.

What’s even more interesting is how the simplicity and efficiency of the MQTT protocol can also be its Achilles' heel. If someone gains unauthorized access to an MQTT broker, they can potentially send malicious messages to control devices. This highlights the importance of securing IoT systems, especially the MQTT brokers, to prevent unauthorized access.

### Final Thoughts

This task allowed me to explore both the technical and practical aspects of MQTT and IoT systems. It was a rewarding experience that not only improved my understanding of IoT communication but also sharpened my skills in network analysis and reverse engineering. The challenge itself reinforced the significance of network security and the need for proper controls in IoT systems. I now have a deeper appreciation for how IoT devices communicate and the potential security risks involved in these systems.

**Answers**

*What is the flag?* **THM{Ligh75on-day54ved}**

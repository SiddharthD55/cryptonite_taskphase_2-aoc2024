#### **Understanding Sandboxing and Registry-Based Detection**

One of the first things I learned about malware is that sandboxing is a common technique used by security professionals to isolate suspicious files. These environments help prevent any damage to the system by executing potentially harmful code in a contained area. However, savvy malware developers often include checks to detect if their code is running in a sandbox.

In my case, I encountered a simple yet effective technique where the malware queries the Windows registry for the presence of the `ProgramFilesDir` key, which is a typical directory for a standard Windows installation. If the registry key is missing, the malware concludes that it’s likely running in a sandbox environment and exits early. Here’s the basic concept of how this registry check works in C:

```c
void registryCheck() {
    const char *regPath = "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion";
    const char *valueName = "ProgramFilesDir";

    char command[512];
    snprintf(command, sizeof(command), "reg query \"%s\" /v %s", regPath, valueName);
    int result = system(command);

    if (result == 0) {
        printf("Registry key found.\n");
    } else {
        printf("Registry key not found; exiting.\n");
    }
}
```

This code attempts to query the registry for the `ProgramFilesDir` value. If the value isn't found, the malware assumes it's in a sandbox and will terminate its malicious behavior. This simple but effective check is often used by malware to avoid detection in virtualized environments.

#### **YARA Rules: A Defender's Best Friend**

As a part of my testing, I also explored **YARA**—a powerful tool for identifying and classifying malware based on patterns in its code. YARA rules allow defenders to define specific patterns (such as strings or file headers) that identify malicious activities.

I wrote a YARA rule specifically designed to detect when the malware queries the registry. The rule looks for a specific string related to the `ProgramFilesDir` registry key:

```yara
rule SandboxDetection
{
    meta:
        description = "Detects sandbox by registry query"
        author = "TryHackMe"
        date = "2024-10-08"

    strings:
        $query = "ProgramFilesDir" nocase

    condition:
        $query
}
```

This rule checks for the presence of the string `"ProgramFilesDir"` within the system logs or files, which is a strong indicator that the malware is attempting to determine whether it is running in a sandbox.

#### **Real-Time Detection with EDR**

Next, I leveraged an Endpoint Detection and Response (EDR) tool to monitor system activity. EDR tools are designed to capture and analyze real-time events, helping defenders identify any suspicious behavior. 

I ran a PowerShell script (`JingleBells.ps1`) that continuously monitored events in the system’s log files. Once the script was active, I launched the malware (`MerryChristmas.exe`) and waited for any alerts.

```powershell
.\JingleBells.ps1
```

If the malware attempted to query the registry, I expected the EDR tool to generate an alert, showing a detection log like this:

```
Event Time: 2024-10-11 15:06:39
Command Line: reg query "HKLM\...\CurrentVersion" /v ProgramFilesDir
```

#### **Evasion via Obfuscation**

While YARA and EDR were able to detect the malware's activity, I quickly realized that there are ways to evade detection. One such method is **obfuscation**, where malware authors disguise the true intent of their code.

For instance, I modified the malware to use a Base64-encoded PowerShell command to query the registry. This technique makes it much harder for tools like YARA to detect the malicious behavior, since the encoded command is not immediately recognizable.

Here’s how I implemented the obfuscated registry query:

```c
void obfuscatedQuery() {
    const char *encodedCommand = "RwBlAHQALQBJ...";
    char command[512];
    snprintf(command, sizeof(command), "powershell -EncodedCommand %s", encodedCommand);
    system(command);
}
```

The `encodedCommand` is a PowerShell command encoded in Base64. When decoded, it executes the same registry query but in a manner that’s harder for static detection tools to spot.

#### **Dealing with FLOSS (Malware String Extraction)**

Despite my efforts to obfuscate the malware, I learned that advanced tools like **FLOSS** (Fast Logs of Strings) can still extract hardcoded strings from malware binaries, even if they are obfuscated. FLOSS is designed to work like the `strings` tool, but it’s optimized for analyzing malware. I ran FLOSS to extract any potentially exposed strings from my obfuscated malware:

```powershell
floss.exe C:\Tools\Malware\MerryChristmas.exe | Out-file C:\tools\malstrings.txt
```

This command scans the malware and writes any extracted strings to a file. By searching for the `THM` string in `malstrings.txt`, I found a flag—my first successful detection in this exercise. The flag format was `THM{...}`, and this step confirmed that even with obfuscation, defenders could still extract useful information from malware binaries.

#### **Sysmon: Advanced Event Logging**

In my journey, I discovered that Sysmon, a tool from Microsoft's Sysinternals suite, provides detailed event logs of system activity, such as process creation, network connections, and registry access. Sysmon allows defenders to track detailed traces of malware behavior.

I configured Sysmon to log and monitor any events related to the malware. By filtering Sysmon logs using a custom filter in Event Viewer, I could track the creation of processes related to the malware and inspect their activity. For example, I tracked the following event:

```
Event ID: 1
Command Line: reg query "HKLM\...\CurrentVersion" /v ProgramFilesDir
```

By monitoring such events, defenders can identify suspicious processes and trace them back to the malware responsible.

#### **Final Thoughts: The Never-Ending Dance**

Despite my efforts to evade detection with obfuscation and sandbox detection techniques, I quickly realized that defenders are not easily fooled. YARA rules, EDR, Sysmon, and FLOSS all provide powerful mechanisms for identifying malware. As a malware author, it was clear that the constant arms race between attackers and defenders would continue. Each new evasion technique I used was met with a countermeasure from the defenders, and it became evident that my malware wasn’t invincible.

Yet, I was determined. I would continue to fine-tune my craft, adapting to each new defense until my malware was truly undetectable. But for now, I had to respect the tools and techniques that defenders use. Their vigilance and expertise are what keep systems secure, and in this ongoing battle, it's clear that the defenders are winning.

**Answers**

*What is the flag displayed in the popup window after the EDR detects the malware?* **THM{GlitchWasHere}**

*What is the flag found in the malstrings.txt document after running floss.exe, and opening the file in a text editor?* **THM{HiddenClue}**
